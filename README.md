# Distributed White Board

# Introduction

With the power of internet, nowadays users can have access to services
anywhere from the world. In this context, a distributed system is
superior to a single machine to serve these needs. Distributed systems
have advantages such as functional separation, inherent distribution,
power imbalance and load variation, reliability and economies.

In this assignment, I will explore the distributed system by designing
and implementing a distributed shared white board using Java to allow
multiple users to draw simultaneously on a canvas.

## System Architecture

From the top, the system will follow client-server architecture. At
start-up, the RMI remote object `remoteWhiteBoard` will be initialised
together with the manager whiteboard on the server and then bind to the
RMI registry. All clients first lookup the `remoteWhiteBoard` service
and create stubs. The clients update their local whiteboards by invoking
methods via the stub.

## Communication Protocols

The communication protocol used is RMI, which consists of remote
interface `RemoteWhiteBoard`. All clients own their local whiteboards
and pull (push) the newest update through `remoteWhiteBoard` stubs. More
details will be discussed in the implementation details section.

## Message Formats

The local whiteboards and the remote whiteboard communicate using
serializable\
`ArrayList<ShapeColor> shapeList` and `String chatHistory`. As for the
message formats for the server-to-client communication, we don't need to
consider since RMI has already taken care.

## Concurrency

Concurrency discussion will be focused on the remote objects. Firstly,
concurrent access to `shapeList` and `chatHistory` is protected by use
of synchronized setters and getters. And concurrency in `userMap` is
taken care by use of `ConcurrentHashMap`.

# Implementation Details

## `RemoteWhiteBoardImpl.java`

The remote servant class implements all methods outlined in
`RemoteWhiteBoard.java` remote interface plus any local and helper
methods. An remote object will have four instance variables, e.g.,
`userCount`, `userMap`, `shapeList` and `chatHistory`. The remote method
`join()` provides functionality for the manager to approve a client's
request to join the whiteboard. It returns the result (0 or 1) showing
whether the manager approves and a useID generated by calling
`createUser()` helper method. The only local method is `createUser()`,
only the manager can call it directly and gets the initial `userID` 0.
The rest remote methods are basically setters and getters for the
`shapeList` and `chatHistory`, and all understandable by their names.

## `CreateWhiteBoard.java`

This is the server class, which registers the `remoteWhiteBoard` and
creates a `managerWindow` containing manager's local whiteboard. After
that, an infinite while loop is making sure the local whiteboard is in
sync with the `remoteWhiteBoard`. In each step, there is also an if
statement to check if the manager gets kicked out. If so, the manager
program should exit. In addition, a time delay of 100ms is in each step
to make the process more legitimate.

## `JoinWhiteBoard.java`

This is the client class, which lookups the `remoteWhiteBoard` in the
registry and then creates a `clientWindow` containing the client's local
whiteboard. Similar to the manager case, an infinite while loop is
making sure the local whiteboard is in sync with the `remoteWhiteBoard`.
Moreover, the client not only needs to check whether itself gets kicked
out, it also has to catch the exception when the manager quits.

## `ClientWindow.java`

This the GUI class for a client. It is set to be GridBagLayout layout
for flexibility. The first row of the grid is for users to choose
shapes, sizes and colors they want to draw. Selection is made via
`JComboBox`. For parameters such as width, height and radius, choices
can be small, median and large. There will also be a `JtextField` for
text input if a user want to type text. As the figures show, the bottom
left area is the actual whiteboard area. The drawing action is
essentially just getting all parameters needed for a `ShapeColor`
instance and adding it to `remoteWhiteBoard`. Since drawing a line
involves dragging between two points and drawing other graphs involves
clicking on a point, this variation of drawing actions is done by
changing `MouseAdapter` when an action is performed in shape selection
`JComboBox`. Moreover, the bottom right area is the chat window. As long
as a user clicked on the send button, it gets and parses text from the
`chatInput` field then appends to the `chatHistory` in
`remoteWhiteboard`. Lastly, as introduced earlier, the `sync()` method
is to make local whiteboard's `shapeList` and `chatHistory` in sync with
`remoteWhiteBoard`.

## `ManagerWindow.java`

The manager GUI class extends the client GUI class. It adds a 'File'
menu with functionalities such as 'new', 'open', 'save', 'saveAs' and
'close' and a 'Manage' menu with 'kick out' functionality. To create a
new whiteboard, we call `emptyWhiteBoard()` on local whiteboard. In
order to apply changes to the `remoteWhiteBoard`, we call its method
`setShapeList()`. 'saveAs' always pops up a `JFileChooser` window to let
user choose the file location to save and call the local whiteboard's
`writeWhiteBoard()`. 'save' will immediately save to the path specified
in `file` attribute if it exists, otherwise it is the same as 'saveAs'.
Note that the actual object being saved is the local whiteboard's
serializable `shapeList`. 'open' is just the reverse, a `JFileChooser`
window pops up to choose the file to open, followed by calling the local
whiteboard's `readWhiteBoard()`. To manage users, the manager first
obtains a list of current users by `getUserList()` (a helper function
for parsing). Then the manager can choose which user to kick out, this
involves `removeUser()` in the `remoteWhiteboard`.

## `WhiteBoard.java`

The `WhiteBoard` class extends the JPanel class. It maintains two
instance variables\
`ArrayList<ShapeColor> shapeList` and `File file`. There is also an
initial configuration, setting the background color to be white in the
constructor and overriding the `getPreferredSize()` method to set the
size of $800\times700$. The painting work is done by the method
`paintComponent(g)`, so we override in such a way that it loops through
all shapes in the `shapeList` and draw them. To draw a new shape on a
local whiteboard, we call `draw()`. The method adds a `shapeColor` to
the `shapeList` and then runs `repaint()`. `readWhiteBoard()` or
`writeWhiteBoard()` uses `ObjectIn(Out)putStream` or
`ObjectOutputStream` to read or write `shapeList` as binary file to the
path specified in `file`. Finally, `emptyWhiteBoard()` just assigns an
empty `shapeList` and sets `file` to `null` then call `repaint()`.

The class `ShapeColor` is just a self-defined class to store information
of a drawn shape. It contains 17 pre-defined color static variables, and
any other information such as shape, coordinates, size and color as
instance variables. The first constructor is for all shapes except texts
and the second constructor is for texts.

# Class Design
[class-diagram.pdf](https://github.com/jiaqiw9/Distributed-Shared-White-Board/files/6528799/class-diagram.pdf)
[sequence-diagram.pdf](https://github.com/jiaqiw9/Distributed-Shared-White-Board/files/6528800/sequence-diagram.pdf)


# Evaluation

The design choices might have following advantages and disadvantages.

-   It is obviously costly to run an infinite while loop to update the
    whiteboard even with 100ms time delay in each step. A better
    solution might be to implement a remote interface in the client side
    as well. Whenever a manager (user) makes change to his whiteboard,
    he can propagate the change by calling some method on both server's
    and client's remote interface.

-   The client-server architecture is better comparing to peer-to-peer
    architecture in this case. Since the manager is the first user
    creates a whiteboard, it is intuitive to start a remote server at
    the manager side at the same time. Moreover, all user applications
    will be terminated when the manager quits. In a peer-to-peer model,
    it will be very hard to differentiate a user's role and a manager's
    role.

-   Of course, the RMI is used as a communication protocol. It handles
    all complexities in threads and sockets and takes care of all
    network issues might occur. However, it might be less flexible
    comparing to the socket programming approach, e.g., no control in
    disconnection of remote interface so client is dependent on the
    server.
